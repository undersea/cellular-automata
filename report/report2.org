#+TITLE:     Using Cellular Automata for Data Mining
#+AUTHOR:    James Hurford
#+EMAIL:     
#+DATE:      
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT: 


#+LaTeX_HEADER: \setlength{\parindent}{0pt}
#+LaTeX_HEADER: \setlength{\parskip}{1em}


* Introduction

  Cellular automata are being used as a modeling tool by
  scientists. The most famous cellular automata is Conway's Game of
  Life, but cellular automata have also been used to model traffic
  flows, chemical reactions, and infection rates.

  In this report we are using a cellular automata for data mining, in
  particular classification, by using a cellular automata as a
  clustering tool, based on the article "Data mining with cellular
  automata" by Tome Fawcett \cite{fawcett08}.

  Fawcett \cite{fawcett08} was interested in a implementation of
  cellular automata showing it could be used as a data mining,
  classification, clustering tool.  It was not to extend a existing
  method, or to create a new method of data mining. Fawcett's
  \cite{fawcett08} aim was to demonstrate that clustering using
  cellular automata can be done.

  The reason Fawcett \cite{fawcett08} is interested in using a
  cellular automata to perform clustering and classification is that a
  cellular automata acts in a similar way to that of nanotechnology
  automata. A cellular automata can be used as a means of
  demonstrating how nanotechnology automata might perform data mining.

* Background
  A cellular automata is a grid of cells of finite dimensions.  Each
  cell has a limited number of states.  These states are usually in
  the form of a number, like zero for off and one for on.  The grid is
  initialised with each cell being in a initial state such as zero.
  It is then put through a series of steps, called generations.

  At each generation the states of the cells are determined from that
  cells immediate neighbours from a simple set of rules.  A rule could
  be if three or more neighbours are in a state of zero then the cells
  state will be one.  At each generation the rules are applied in
  parallel, so the states of the cells get determined all at the same
  time.

  There are several forms of neighbourhoods with the two most popular
  being Von Neumann neighbourhood, as shown in figure 1, and Moore's
  neighbourhood as shown in figure 2. 

  
#+CAPTION: Von Neumann neighbourhood with neighbours north, south, east and west
#+attr_latex: width=10em \textwidth
#+BEGIN_DITAA  von_neumann_diagram -r -S -E
      +-----+
      |c999 |
      |  N  |
+-----+-----+-----+
|  W  |Cell |  E  |
|c999 |     |c999 |
+-----+-----+-----+
      |c999 |
      |  S  |
      +-----+
#+END_DITAA

#+CAPTION: Moore's neighbourhood with neighbours north, northeast, east, southeast, south, southwest, west and northwest
#+attr_latex: width=10em \textwidth
#+BEGIN_DITAA  moores_diagram -r -S -E
+-----+-----+-----+
|c999 |c999 |c999 |
| NW  |  N  | NE  |
+-----+-----+-----+
|  W  |Cell |  E  |
|c999 |     |c999 |
+-----+-----+-----+
|c999 |c999 |c999 |
| SW  |  S  | SE  |
+-----+-----+-----+
#+END_DITAA

Fawcett \cite{fawcett08} chose to use a none toroidal finite grid,
which considers points off the grid as dead zones, thus permanently
empty.  There was no reason given for this, however this could be
because in a nanotechnology environment it may not be physically
possible to wrap the edges around to form a toroid.

* Data Mining (Clustering)

  Fawcett \cite{fawcett08} decided to use cellular automata as a
  instance based learner. The cellular automata shall be organised so
  that each axis represents a predicate, so a range of cells represent
  a particular class in the instance space.  The grid is seeded with
  training data.  This takes the form of taking attribute values and
  using them as the coordinates into which the class value is
  assigned.  The cellular automata is run until convergence, which
  takes place when no cell is in the unassigned state.  The cellular
  automata is run a further ten times to make sure it is a stable
  state, and will not change.

  The state of each cell, as shown in figure 3, represents a class
  assignment with the intention of the cells organising themselves
  into areas of the same class.
#+CAPTION: An example of how cells may organise themselves to represent areas of the same class
#+attr_latex: width=20em \textwidth
#+BEGIN_DITAA class_regions_diagram -r -S -E
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 1 | 1 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
+---+---+---+---+---+---+---+---+---+---+
#+END_DITAA

The cellular automata does this by using a simple voting system which
has the effect of reducing uncertainty of the outcome. The majority
wins approach is used.  If the majority of the cells neighbours
are of one class then the cell changes its value to that class.  The
effect of this is that when convergence happens, where all cells are
assigned a class, then the class of the cells will remain static.  No
matter how many more iterations the cellular automata goes through
after this moment. There is a problem of what to do if there is a
deadlock where the neighbours classes end up with a even number of 2
or more classes.  In this case the conflict is resolved by randomly
picking between the classes. The voting, as illustrated in figure 4, rules are
defined in figure 5. This voting system is insensitive to neighbours
location. The rules used by the cellular automata, as shown in figure
5, are a modification of Fawcett's \cite{fawcett08} rules.  I
am allowing for more than one class, where as Fawcett \cite{fawcett08}
is only allowing for only two classes.  

Fawcett \cite{fawcett08} says that cellular automata is good at
solving two class problems. This implies that, cellular automata, do
not do as well on classification problems, with more than two classes. 
#+CAPTION: Voting system illustrated where the centre cells value is determined by its surrounding neighbours
#+attr_latex: width=30em \textwidth
#+BEGIN_DITAA voting_system -r -S -E
    +-----+          +-----------+          +-----+
    |  1  |          |     1     |          |  0  |
+---+-----+---+  +---+-----------+---+  +---+-----+---+
|   |c999 |   |  |   | c999      |   |  |   | c999|   |
| 2 |*1*  | 1 |  | 2 |*rand{1,2}*| 1 |  | 0 |  0  | 0 |
+---+-----+---+  +---+-----------+---+  +---+-----+---+
    |  1  |          |     2     |          |  0  |
    +-----+          +-----------+          +-----+
   Winner            Stalemate              All neighbours
   1 is the          neither side wins         are 0
   majority so       so picks from two
   one is picked     values at random
#+END_DITAA

#+CAPTION: The rules used by the cellular automata
#+attr_latex: width=40em \textwidth
#+BEGIN_DITAA rules_definitions -r -S -E
/----------------------------------------------------------------------------\
| 1. If neighbour is unassigned then the vote from this cell does not        |
|    count                                                                   |
| 2. Cell is equal to the value of the majority of the values of the         |
|    surrounding cells.                                                      |
| 3. If there is a stalemate then the result is resolved by randomly         |
|    picking between the possible values.                                    |
| 4. If the sum of all neighbours are zero then cells value does not change. |
|                                                                            |
\----------------------------------------------------------------------------/
#+END_DITAA



Fawcett \cite{fawcett08} uses the Von Newsman neighbourhood as it is
linear in number of dimensions. So if there are two dimensions then
there will be four neighbours,  if three dimensions, then there will
be six neighbours.  So for every dimension added, two more neighbours
will be added.  This, according to Fawcett \cite{fawcett08} makes it
scale well.

The global affect of these update rules is that each cell in the grid
is assigned the value of its nearest neighbour, as measured by the
Manhattan distance.  This is called the Manhattan effect.

* Implementation of Fawcett's \cite{fawcett08} idea


The programming language chosen is C++ making use of Standard Template
Library (STL).  This is a command line programme, which needs to
parameters passed to it, the path to the file containing the training
data and the path to the file containing the test data.

Fawcett \cite{fawcett08} used data sets from from UCI Machine Learning
Repository http://archive.ics.uci.edu/ml/index.html.  For this
implementation the Iris data set is used.

To be able to use any data sets for this programme, they must be
transformed into a format the programme can use, and predicate values
must be transformed into integer form, so they can be used as
addresses for the array which represents the grid.  A value of 0.23
can not be used as a address in a computer array.  Also string values
for classes can not be used in this implementation as only integer
values are supported.  Also the data needs to be split into training
and test data.  To overcome this the float values are multiplied by
the appropriate value so that the decimal point is shifted to the
right and the number that is now left of the decimal point is used and
the rest is discarded.  This will lead to loss in accuracy, but as far
as classification is concerned, the values seem to be accurate enough.

To do this transformation a python script was created and float values
were turned into integer values and the result outputted into 3 files.
These are the definition file containing the dimensions of the grid to
create. The training data file and the testing data file.

To run the programme it requires three parameters, which represent the
path to the grid definitions file, the training data file, and then
the testing data file. 

The grid definitions file contains in one line, separated by spaces,
the number of dimensions, and the maximum size for each of these
dimensions. The number of dimensions is the number of predicates, or
predictors used.  These are the attributes of each class. Each
predicate has a range of values it can have, so I chose to just go
from zero to the maximum possible value plus one, for each predicate.

The training data file has a list of predicates followed by their
class value.  These are all integer values.  Each entry is on a
separate line.  The same format is used for the testing data.

The programme does not run multiple processes of any kind, so
therefore can not update every cell for each generation in parallel.
However this can be simulated by having two grids, one of them has the
values from the current generation and the other is used to write the
next generations values to then swapping them over for the next
generation.

Each cell is updated from the values of its neighbours
using the voting system rules.  Since it the number of classes can
vary, depending on the data set, the cell uses the majority of what is
there and if there is a stalemate, then the cell resolves this by
randomly  picking between the available classes contained in its
neighbours. 

At each step the programme checks to see if all cells have
a class assigned to them.  If the do it runs for ten more generations
to make sure the grid is stable, as in no more changes can take place.

* Results

  The Iris data set was used.  The predicates are sepal length,
  sepal width, petal length, and petal width.  The aim is to use these
  predicates to figure out what class of Iris the data refers to.  These
  classes are  Iris Setosa, Iris Versicolour, and Iris Virginica.  The
  predicate values are transformed into integer values and so is the
  class values.

  The programme was run several times, each time with less training
  data. The results are shown in table 1. When the programme was run, in
  general, the more training data was used, the more accurate the
  results.  The anomaly of the half training suggests that, like any
  other algorithm, the accuracy depends on the input data that is
  used. The only way the results can be changed is to change the input
  data used.

  The results from the same data always give the same result and does so
  in the same number of steps, every time.  This shows that cellular
  automata do in fact exhibit a stable 

#+CAPTION: Results from the iris data set with varying amounts of training data
|---------------+------------|
| Amount of     | Percentage |
| training data |    correct |
|---------------+------------|
| 1/4 training  |  86.607143 |
| 1/3 training  |  94.897959 |
| 1/2 training  |  98.666667 |
| 2/3 training  |        94. |
| 3/4 training  |        100 |
|---------------+------------|
#+TBLFM: @3$2=(97 / 112)*100::@4$2=(   93 / 98)*100::@5$2=(74 / 75) * 100::@6$2=(47 / 50)*100::@7$2=(38 / 38) *100


* Conclusions
  The results show that cellular automata can be a effective
  classifier.  From a simple set of voting rules, individually applied
  by each cell, using only its immediate neighbours, comes a
  collective behaviour that can be used as a classifier.
* Future work
  It would be desirable to use other data sets and see if a similar
  performance can be achieved.

  Also work on making the amount of time and memory needed for the
  cellular automata smaller.  

  Also it would be good to see if similar results could be achieved
  used a fixed size grid of smaller size than that of the range of the
  predicates used.  Some sort of modulus calculation could perhaps be
  used.


\bibliographystyle{plain}
\bibliography{bibliography}
